# 1.为什么可以返回函数中定义的局部变量，函数调用结束后不会释放该变量的内存吗？

```c++
 int WorkerManager::IsExist(int id)
{
	int index = -1;

	for (int i = 0; i < this->m_EmpNum; i++)
	{
		if (this->m_EmpArray[i]->m_Id == id)
		{
			//找到职工
			index = i;

			break;
		}
	}

	return index;
}
```

在这个函数`WorkerManager::IsExist`中，返回的是一个整型变量`index`，而不是一个指向局部对象的指针或者引用。基本数据类型（如整型`int`）在函数返回时，其值会被复制到接收该返回值的变量中，而不是返回其内存地址。

因此，<font color='red'>当你返回一个基本数据类型的变量时，实际上返回的是它的一个副本</font>。这就是为什么即使原始变量`index`在函数返回后其作用域结束并被销毁，返回的值仍然有效的原因。调用者接收到的是这个值的一个拷贝，与原始变量`index`在函数内部的存储是分开的。所以，这段代码是安全的，不会因为返回局部变量而引发错误。

<font color='red'>反例：</font>

在 C++ 中，有些情况下确实不能返回函数中定义的局部变量。这种情况通常出现在尝试返回指向局部变量的指针或引用时，因为这些指针或引用在函数返回后会失去其指向的对象，导致未定义行为或者悬空指针的问题。

举个例子，假设有如下函数：

```c++
int* createArray(int size) {    
  int arr[size];  // 局部数组     
  // 在数组上进行一些操作，例如初始化等     
  return arr;  // 尝试返回局部数组的指针 
}
```

在这个例子中，`createArray` 函数试图返回一个指向局部数组 `arr` 的指针。然而，一旦函数执行完毕并返回，`arr` 将超出其作用域，因此指向 `arr` 的指针将成为悬空指针，指向无效的内存地址，访问它可能导致未定义行为。

<font color='red'>正确的做法应该是使用堆内存分配</font>，例如使用 `new` 运算符：

```c++
int* createArray(int size) {    
  int* arr = new int[size];  // 在堆上分配数组内存     
  // 在数组上进行一些操作，例如初始化等     
  return arr;  // 返回指向堆分配数组的指针 
}
```

<font color='red'>这样做可以确保数组在函数返回后仍然有效</font>，因为在堆上分配的内存不会在函数结束时被释放，需要调用者负责在合适的时机通过 `delete[]` 来释放这段内存，以避免内存泄漏。

因此，要避免返回函数中局部变量的指针或引用，特别是指向栈上分配的内存的指针，以确保程序的正确性和健壮性。





