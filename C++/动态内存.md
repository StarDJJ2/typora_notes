# 动态内存分配   C和C++在动态内存分配上的区别

[【C++】动态内存分配详解（new/new[\]和delete/delete[]）-CSDN博客](https://blog.csdn.net/qq_40416052/article/details/82493916)



在C++中，使用动态内存分配通常有以下几种情况：
1. **不确定的数据量**：当数据的大小在编译时是未知的，而且大小可能在运行时变化时，需要使用动态内存分配。例如，程序中处理的输入数据量可能每次执行时都不同，这时就需要根据实际需要来动态地分配内存。
2. **大量内存需求**：当对象需要大量内存且可能会超出栈的大小（栈大小相对受限）时，使用动态内存可以从堆上分配。
3. **控制对象的生命周期**：动态内存分配允许在运行时创建对象，这些对象可以在函数调用结束后继续存在。只要不释放这些对象所用的内存，这些对象就不会被销毁。
4. **无法使用自动或静态存储持续期的情况**：有些对象需要根据特定情况创建和销毁，而与函数的调用保持独立，这时就需要动态内存管理。
5. **<font color='red'>复杂数据结构</font>**：对于链表、树、图等复杂数据结构，节点往往在运行时动态创建和销毁，这些结构的大小和形状在编译时是不可知的，因此需要动态内存分配。   <font color='red'>目前唯一见到的</font>
6. **避免碎片化**：动态内存分配可以有效管理内存碎片，尤其是在频繁地增加和删除对象时，为了内存资源的高效利用，可能需要动态地申请和释放内存。
7. **优化性能**：在一些性能敏感的应用程序中，用于优化程序的内存使用效率和访问速度，例如对象池（object pools）技术，便需要动态内存分配。
总的来说，动态内存分配提供了在运行时管理内存的灵活性，但也带来了需要程序员手动管理内存生命周期的责任，这意味着要注意内存泄漏和野指针的问题。正确使用new和delete操作符（或智能指针如std::unique_ptr和std::shared_ptr）是确保资源正确管理的关键。



下面是一个简单的C++代码示例，展示了如何<font color='red'>根据不确定的数据量动态分配内存</font>：
```cpp
#include <iostream>
int main() {
    int n;
    std::cout << "请输入你想要的整数数量：";
    std::cin >> n;
    // 使用new操作符动态分配数组
    int* arr = new int[n];
    // 初始化并打印数组元素
    for (int i = 0; i < n; ++i) {
        arr[i] = i;
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
    // 使用完成后释放内存
    delete[] arr;
    return 0;
}
```
这个程序首先询问用户需要多少个整数，然后根据用户输入的数量使用`new`操作符动态分配数组。接着，程序遍历数组进行初始化并打印每个元素。最后，当不再需要这块内存时，使用`delete[]`操作符正确释放动态分配的数组内存，防止内存泄漏。
这个示例简明地展示了如何根据用户的输入动态地分配和释放内存。这在处理用户输入或者数据量在运行时才能确定的情况下特别有用。





当然可以。在C++中，如果你想要<font color='red'>分配大量内存</font>，而这可能超过栈（stack）上的分配限制，你可以从堆（heap）上动态分配内存。这通常通过使用`new`操作符完成。下面是一个C++的代码例子，展示如何为一个整数数组动态分配内存：
```cpp
#include <iostream>
class LargeArray {
public:
    int* array;
    // 构造器
    LargeArray(std::size_t size) {
        array = new int[size];
    }
    // 析构器
    ~LargeArray() {
        delete[] array;
    }
};
int main() {
    std::size_t largeSize = 1000000; // 比如我们需要一个100万个整数的数组
    LargeArray obj(largeSize);
    // ... 这里可以使用obj.array这个大数组...
    // 当obj超出范围时，其析构函数会自动被调用，从而释放内存
    return 0;
}
```
在这个例子中，我们定义了一个`LargeArray`类，它有一个指向整数数组的指针。在构造器中，我们使用`new`来动态地从堆上分配一大块内存给数组。然后在析构器中，我们使用`delete[]`来释放动态分配得到的那块内存。这样，即使是非常大的数组，也不会因为超出栈（stack）的限制而导致程序崩溃。注意，使用堆分配内存时，你必须确保之后释放它，否则会发生内存泄露。在本例中，`LargeArray`类的析构器正是干这个的。



# 在C++中不释放内存会导致什么结果

在C++中，如果你不释放你通过`new`关键字分配的内存，那么最终会导致内存泄漏。内存泄漏发生在程序分配了内存但是失败在适当的时机里将它释放回操作系统。如果一个程序持续运行，并且频繁地泄漏内存，最终可用的内存数量会逐渐减少，这可能导致以下几个问题：
1. 程序的性能下降：随着越来越多的内存被占用（并且不被释放），新的内存分配可能会更慢，因为操作系统需花费更多时间来寻找可用的内存片段。
2. 系统资源耗尽：在极端情况下，如果内存泄漏严重或者程序运行了很长时间，可能最终耗尽系统所有可用内存。这会影响到其他运行中的程序，并可能导致系统不稳定。
3. 程序崩溃：最终，如果程序尝试分配内存但是系统没有足够的内存可用，可能会导致程序崩溃或者异常终止。
4. 系统崩溃：如果是系统级程序或者服务造成的内存泄漏，那么影响可能更加严重，甚至有可能导致整个系统崩溃。
因此，合理管理内存资源，在不再需要动态分配的内存时确保及时释放它们，对于保障程序稳定性和效率至关重要。



# delete使用条件

## 使用 delete 删除内存空间的条件

在 C++ 中,`delete` 运算符用于释放通过 `new` 运算符动态分配的内存空间。因此,只有通过 `new` 分配的内存空间才能使用 `delete` 来释放。

具体来说,可以在以下情况下使用 `delete` 来删除原有空间:

1. **单个对象**: 如果使用 `new` 创建了单个对象,则可以使用 `delete` 来释放该对象所占用的内存空间。例如:

```cpp
MyClass* obj = new MyClass();
// ... 使用对象
delete obj; // 释放对象所占用的内存空间
```

2. **动态数组**: 如果使用 `new[]` 创建了动态数组,则需要使用 `delete[]` 来释放该数组所占用的内存空间。例如:

```cpp
int* arr = new int[10];
// ... 使用数组
delete[] arr; // 释放数组所占用的内存空间
```

需要注意的是,如果你尝试使用 `delete` 释放不是通过 `new` 分配的内存空间,或者使用 `delete[]` 释放单个对象的内存空间,都会导致未定义行为,可能会引发程序崩溃或内存泄漏等问题。

此外,对于静态分配的内存空间(如全局变量、静态变量、栈上的变量等),不需要也不应该使用 `delete` 或 `delete[]` 来释放,因为它们的生命周期由编译器自动管理。

总的来说,只有通过 `new` 或 `new[]` 动态分配的内存空间才需要使用 `delete` 或 `delete[]` 来手动释放,以避免内存泄漏。



# new运算符封装了malloc运算符

在 C++ 中，`new` 运算符和 C 语言中的 `malloc` 函数都用于动态分配内存，但它们在功能和使用上有重要的区别。理解 `new` 运算符封装了 `malloc` 函数的说法，我们可以从以下几个方面进行探讨：

### 1. **功能差异**

- **malloc**：仅负责分配指定大小的内存块，并返回一个指向该内存的指针。`malloc` 不会初始化内存，返回的内存块内容是未定义的。
- **new**：不仅分配内存，<font color='red'>还负责对象的构造</font>。这意味着 `new` 在分配了足够的内存后，会自动调用对象的构造函数（如果有的话），以初始化对象。

### 2. **封装性**

- 当你使用 `new` 时，实际上它在底层可能会调用 `malloc`（或者类似的函数，如 `operator new`，这是 C++ 标准库的一部分，允许被重载）来分配所需的内存。然后，`new` 会在分配的内存上调用构造函数以形成对象。
- 从这个意义上说，<font color='red'>`new` 可以被视为封装了 `malloc`，因为它提供了额外的功能（即自动调用构造函数），隐藏了内存分配的底层细节</font>。

### 3. **类型安全和返回类型**

- <font color='red'>**malloc** 返回的是 `void*` 类型</font>，这需要你将其显式转换为适当的类型指针。
- **new** 返回的指针类型直接与分配的对象类型相匹配，无需进行类型转换，从而提高了类型安全。

### 4. **错误处理**

- 当内存分配失败时，`malloc` 返回 `NULL`（或在 C++ 中的 `nullptr`）。
- `new` 在默认情况下会抛出一个 `std::bad_alloc` 异常，除非使用了 `new(std::nothrow)` 形式，这时它会返回 `nullptr`。

### 5. **例子**

下面是一个展示 `new` 和 `malloc` 使用差异的简单例子：

```cpp
#include <iostream>
#include <cstdlib>  // For malloc

class MyClass {
public:
    MyClass() {
        std::cout << "Constructor called." << std::endl;
    }
    ~MyClass() {
        std::cout << "Destructor called." << std::endl;
    }
};

int main() {
    // 使用 malloc
    MyClass *ptr = (MyClass *)malloc(sizeof(MyClass)); // malloc不调用构造函数
    free(ptr); // free不调用析构函数

    // 使用 new
    MyClass *ptr2 = new MyClass(); // new调用构造函数
    delete ptr2; // delete调用析构函数

    return 0;
}
```

在这个例子中，使用 `malloc` 时，不会调用 `MyClass` 的构造函数和析构函数。而使用 `new` 和 `delete` 时，构造函数和析构函数会自动被调用，确保了对象生命周期的完整管理。

总结来说，`new` 操作符在功能上封装和扩展了 `malloc`，使得其不仅可以进行内存分配，还能处理对象的构造和类型安全，更适合 C++ 的面向对象编程。