1.引用概念上定义一个变量的别名，指针存储一个变量地址。

2.引用在定义时必须初始化，指针没有要求

3.引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体

```cpp
#include <iostream>

int main() {
    int x = 10;
    int y = 20;

    // 引用初始化时绑定到x，之后不能改变
    int& ref = x;
    std::cout << "ref: " << ref << std::endl; // 输出：ref: 10

    // 尝试改变ref的绑定
    // ref = y; // 这行代码实际上是改变了x的值，而不是改变ref的绑定
    // std::cout << "ref: " << ref << std::endl; // 输出：ref: 20
    // std::cout << "x: " << x << std::endl; // 输出：x: 20

    // 指针初始化时指向x，之后可以改变指向
    int* ptr = &x;
    std::cout << "ptr: " << *ptr << std::endl; // 输出：ptr: 10

    // 改变ptr的指向
    ptr = &y;
    std::cout << "ptr: " << *ptr << std::endl; // 输出：ptr: 20

    return 0;
}

```

4.没有NULL引用，但有NULL指针

5.在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32
位平台下占4个字节)
6.引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小

7.有多级指针，但是没有多级引用

多级指针，顾名思义，就是指针的指针。也就是说，一个指针变量存储的是另一个指针变量的地址。

例如，我们可以有一个int型的指针变量，这个变量存储的是一个int型变量的地址。然后，我们可以有一个指向int型指针的指针变量，这个变量存储的是那个int型指针变量的地址。这就是二级指针。

下面是一个二级指针的例子：

```cpp
#include <iostream>

int main() {
    int x = 10; // 一个int型变量
    int* p = &x; // 一个指向int的指针
    int** pp = &p; // 一个指向int*的指针，也就是二级指针

    std::cout << "x: " << x << std::endl; // 输出：x: 10
    std::cout << "*p: " << *p << std::endl; // 输出：*p: 10
    std::cout << "**pp: " << **pp << std::endl; // 输出：**pp: 10

    return 0;
}
```

在这个例子中，`pp`是一个二级指针，它存储的是指针`p`的地址。我们可以通过两次解引用操作`**pp`来获取`x`的值。

同样的，我们也可以有三级指针，四级指针，等等。但是在实际编程中，多级指针的使用并不常见，因为它们往往会使代码变得复杂且难以理解。

8.访问实体方式不同，指针需要显式解引用，引用编译器自己处理

9.引用比指针使用起来相对更安全

原文链接：https://blog.csdn.net/2202_75605090/article/details/134071080