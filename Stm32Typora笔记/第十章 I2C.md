# 同步时序和异步时序

同步时序和异步时序是两种不同的时序控制方式。

**同步时序**

同步时序是指所有操作都由一个统一的时钟信号进行控制。在同步时序电路中，所有触发器的时钟输入端都连接到同一个时钟信号，因此所有触发器都将在同一时刻进行状态变化。

同步时序电路具有以下特点：

- 操作具有规律性，可以预测。
- 设计和调试相对简单。
- 容易受到时钟信号干扰。

**异步时序**

异步时序是指各个操作的执行不受统一时钟信号的控制，而是由各自的事件触发。在异步时序电路中，触发器的时钟输入端由不同的事件信号控制，因此触发器可以在不同的时刻进行状态变化。

异步时序电路具有以下特点：

- 操作没有规律性，难以预测。
- 设计和调试相对复杂。
- 不容易受到时钟信号干扰。

**选择**

选择使用同步时序还是异步时序取决于具体的应用需求。

- **如果需要精确的时序控制，则应使用同步时序。**
- **如果不需要精确的时序控制，则可以使用异步时序。**

**总结**

同步时序和异步时序是两种不同的时序控制方式。选择使用哪种方式取决于具体的应用需求。

以下是一些关于同步时序和异步时序的额外信息：

- **同步时序电路通常使用时钟信号来控制触发器的状态变化。**
- **异步时序电路通常使用事件信号来控制触发器的状态变化。**
- **同步时序电路的設計和调试相对簡單。**
- **异步时序电路的設計和调试相对复杂。**
- **同步时序电路容易受到时钟信号干扰。**
- **异步时序电路不容易受到时钟信号干扰。**

**示例**

以下是一个同步时序电路的示例：

C

```c
void main()
{
  while (1)
  {
    // 等待时钟信号到来
    while (!clock_signal);

    // 进行操作
    // ...
  }
}
```

在这个示例中，操作由时钟信号进行控制。只有当时钟信号到来时，才会进行操作。

以下是一个异步时序电路的示例：

C

```c
void main()
{
  while (1)
  {
    // 等待事件信号到来
    while (!event_signal);

    // 进行操作
    // ...
  }
}
```

在这个示例中，操作由事件信号进行控制。只有当事件信号到来时，才会进行操作。

# 外置弱上拉电阻+开漏输出的电路结构，可以同时兼具输入和输出功能



![img](https://pic1.zhimg.com/v2-2c8aca35994190f43e7a108940f31b60_r.jpg)

根据图中所示,这是一个场效应管电路。在这种典型的放大电路连接中:

源极(Source)连接到地线,作为参考电位。

漏极(Drain)通过电阻T2连接到电源VCC,构成了漏极负载。

栅极(Gate)连接到输入信号"内部输出",用于控制场效应管的开通和截止状态。

因此,该场效应管的源极接地,漏极经T2负载电阻接正电源,栅极接受内部输出的控制信号。这种连接方式能实现对输入信号的放大和缓冲,输出端子为"单片机I/O"。



在这个电路中,场效应管的漏极通过上拉电阻T2连接到VCC电源,<font color='red'>实现输出高低电平</font>的方式如下:

1. 当内部输出为低电平时,场效应管处于截止状态,等效为一个很高的电阻。此时漏极端由于上拉电阻T2的作用,会被拉至接近VCC的高电平。因此,单片机I/O输出为高电平。

2. 当内部输出为高电平时,场效应管被导通,漏极和源极之间形成一个低电阻通路,使得漏极端接近地线的低电平。此时,单片机I/O输出为低电平。

所以通过场效应管的开通和截止状态,加上漏极端的上拉电阻T2,可以实现对内部输出信号的反向输出,当输入低电平时输出高电平,当输入高电平时输出低电平。

这种"漏极开路输出"电路广泛应用于数字逻辑电路的输出级、缓冲级等,能够驱动其他数字电路,同时也具有一定的电流驱动能力。上拉电阻的值需要合理选择,以确保输出电平满足要求。



好的,我来结合电路原理解释一下上拉电阻在该场效应管输出电路中实现高低电平输出的作用:

1. 输出高电平时的作用:
当场效应管处于截止状态(栅极输入低电平)时,其漏极与源极之间等效为一个非常高的电阻,接近开路状态。此时漏极端的电位主要由上拉电阻T2决定。由于T2的一端连接VCC电源,因此漏极端会被拉高至接近VCC的电平,输出为高电平。上拉电阻的作用是在管子关断时,将漏极端拉到逻辑高电平。

2. 输出低电平时的作用:  
当场效应管导通(栅极输入高电平)时,其漏极与源极之间等效为一个很小的电阻值,构成漏极-源极之间的通路。这时漏极端会被拉至接近地线的低电平,实现输出低电平。由于管子本身的导通特性,上拉电阻对低电平输出的影响较小。

3. 上拉电阻阻值的选择:
上拉电阻T2的阻值需要适中。过小会导致管子导通时过大的漏极电流; 过大会影响高电平输出电压,使其偏低。一般需要根据电路的驱动能力、负载等因素合理选择。

总之,上拉电阻在该输出电路中起到了"在管子关断时拉高漏极电位"的作用,以实现高电平输出;而低电平输出主要由场效应管本身的导通特性决定。合理选择上拉电阻可获得理想的高低电平输出波形。



# 上拉电阻 是怎么将漏极端拉到逻辑高电平的？

上拉电阻将漏极端拉到逻辑高电平,是通过电阻分压原理实现的。具体过程如下:

1) 上拉电阻T2的一端连接VCC电源正极,另一端连接场效应管的漏极。

2) 当场效应管处于截止状态(栅极输入低电平)时,管子内部等效为一个极高的电阻,接近开路。

3) 此时漏极和源极之间等效为一个断路,漏极端与VCC电源之间只有上拉电阻T2相连。

4) 根据电阻分压原理,漏极端的电压将由T2和管子内部的极高阻抗两者的比值决定。

5) 由于管子内部阻抗远高于T2,因此绝大部分VCC电源电压将分落在这个极高阻抗上。

6) 这就使得漏极端的电位接近VCC电源电压,达到了逻辑高电平。

7) 上拉电阻T2的作用是在管子截止时,将漏极端"拉"到逻辑高电平,从而实现高电平输出。

所以通过与VCC电源构成电阻分压,并利用场效应管截止时的极高阻抗特性,上拉电阻能够把漏极端"拉"到接近电源电压的逻辑高电平。这是实现高低电平输出的关键。



# 逻辑电平由什么决定？由电压吗？

是的,逻辑电平是由电压值来定义和区分的。

在数字电路中,通常将一定范围的高电压定义为逻辑"1",较低电压范围定义为逻辑"0"。这些高低电压范围就是逻辑电平的定义。

常见的逻辑电平标准有:

1) TTL逻辑电平
   逻辑1: 2.0V以上
   逻辑0: 0.8V以下

2) CMOS逻辑电平 
   逻辑1: 0.7×VCC以上
   逻辑0: 0.3×VCC以下
   (其中VCC为CMOS电路的工作电压)

3) 3.3V CMOS逻辑电平
   逻辑1: 2.0V以上 
   逻辑0: 0.8V以下

4) 5V电平
   逻辑1: 2.4V以上
   逻辑0: 0.8V以下

不同的逻辑电平标准会略有差异,但本质上都是利用不同的电压值区分代表0和1的状态。只要电压处于定义的高电平范围,就视为逻辑1;反之为逻辑0。

所以逻辑电平确实是由具体的电压值来定义和判断的,是数字电路中最基本最重要的概念之一。

![image-20240306092610506](F:\Typora导出文件\Stm32Typora笔记\assets\image-20240306092610506.png)



# 在一副图中，该如何分辨上拉电阻和下拉电阻呢？

在电路图中,可以通过以下几个方面来分辨上拉电阻和下拉电阻:

1. 连接位置
上拉电阻一端连接电源正极(VCC)
下拉电阻一端连接电源负极(GND或地线)

2. 与器件的连接关系
上拉电阻通常连接在被驱动器件(如三态门、开漏器件等)的输出端
下拉电阻通常连接在输入端

3. 器件的工作状态
对于开漏或开集电路,当器件处于关断状态时,上拉电阻使输出端电平保持高电平
当器件处于导通状态时,下拉电阻使输入端电平保持低电平

4. 电阻符号
有时候电路图会使用特殊的符号标注上拉和下拉电阻,比如上拉用Pull-up、下拉用Pull-down

5. 电路功能
根据该电路的功能也可判断,如果是给高阻态输出端提供定义的高电平,那就是上拉电阻
如果是给输入端提供低电平偏置,那就是下拉电阻

总的来说,关注电阻两端的连接点、与器件连接的关系,结合器件的工作原理和电路功能,可以较为准确地区分上拉电阻和下拉电阻。



# 从机地址移位

在计算机中，左移一位就是将数字的所有二进制位向左移动一个位置，并在右侧补0。 十六进制数0x68转换成二进制是01101000。将这个二进制数左移一位（即所有的位都向左移动一个位置）得到11010000，再转换回十六进制就是0xD0。  

这里是二进制和十六进制之间的转换关系：

1.二进制 0110 映射到十六进制就是 6

2.二进制 1000 映射到十六进制就是 8 

3.二进制 1101 映射到十六进制就是 D 

4.二进制 0000 映射到十六进制就是 0 

所以，十六进制数0x68左移一位得到0xD0。



# 接收前，主机为什么要先确保释放SDA？

在 I2C 通信中，SDA 线用于双向数据传输。在接收数据之前，主机需要确保释放 SDA 线，避免干扰从机的数据发送。这是因为：

**1. I2C 总线仲裁机制**

I2C 总线使用仲裁机制来解决多个设备同时访问总线的问题。<font color='red'>仲裁机制规定，谁先拉低 SDA 线，谁就获得总线的控制权</font>。如果主机在接收数据之前没有释放 SDA 线，则可能会发生以下情况：

- 从机在发送数据时，如果检测到 SDA 线已经被拉低，则会认为总线被其他设备占用，从而放弃发送数据。
- 主机在接收数据时，如果 SDA 线被其他设备拉低，则可能会接收错误的数据。

**2. I2C 数据传输协议**

I2C 数据传输协议规定，在数据传输开始之前，发送方必须先拉低 SDA 线，然后发送起始信号。如果主机在接收数据之前没有释放 SDA 线，则可能会导致以下情况：

- 从机无法检测到起始信号，从而无法开始数据传输。
- 主机无法正确识别起始信号，从而导致数据接收错误。

**3. 避免ESD干扰**

在实际应用中，SDA 线可能会受到外部电磁干扰 (EMI) 的影响，例如静电放电 (ESD)。如果主机在接收数据之前没有释放 SDA 线，则可能会导致 ESD 干扰影响数据传输。

**总结**

为了确保 I2C 通信的可靠性，在接收数据之前，主机必须先确保释放 SDA 线。这可以避免干扰从机的数据发送，确保数据传输协议的正确执行，并降低 ESD 干扰的影响。

**释放 SDA 线的方法**

在 STM32 中，可以使用以下方法来释放 SDA 线：

- 使用 GPIO_WriteBit() 函数将 SDA 线设置为输出模式，并输出高电平。
- 使用 GPIO_SetBits() 函数将 SDA 线设置为高电平。

例如，以下代码将释放 SDA 线：



<font color='red'>主机释放SDA后从机就能任意写数据啦</font>





起始信号和终止信号

在STM32的I2C通讯协议中，起始条件和终止条件的生成使用特定的信号模式是为了确保通讯协议的顺畅执行和数据传输的准确性。这两个条件对于标示通讯会话的开始和结束至关重要，它们通过特定的电平变化在通讯双方之间建立了一种协议上的约定。

起始条件\n\n在I2C通讯中，起始条件是通过将SDA（数据线）从高电平拉低到低电平，而在此期间SCL（时钟线）保持在高电平。这个特定的信号模式告诉从机一个新的通讯会话即将开始，它允许主机占有控制权，开始发送地址和数据。

具体步骤如下：

1. 释放SDA，确保SDA为高电平。

2. 释放SCL，确保SCL为高电平。

3. 在SCL保持高电平的状态下，拉低SDA，产生起始信号。

4. 紧接着拉低SCL，准备开始数据传输。

   终止条件

   终止条件则与起始条件相反，它是通过将SDA从低电平拉高到高电平，而在此期间SCL保持在高电平来实现的。这个信号模式向从机表明当前的通讯会话已经结束，主机释放了总线，允许其他主机如果存在的话，可以开始它们的通讯会话。

   具体步骤如下：

   1. 拉低SDA，确保SDA为低电平。

   2. 释放SCL，使SCL呈现高电平。

   3. 在SCL保持高电平的状态下，释放SDA，产生终止信号。

   为什么使用这种方式。使用这种方式进行编程，是为了遵循I2C协议的规定，保证通讯的成功率。起始和终止条件是I2C协议中定义的两个基本操作，它们是区分不同通讯会话的关键。通过这样的电平变化，可以确保主机和从机之间的通讯有明确的开始和结束，避免数据混乱，保证数据的完整性和准确性。在STM32及其他支持I2C通讯的微控制器中，这种操作法是常见的实践，被广泛应用于各种I2C设备通讯中。





那么为什么起始信号代码中最后要在起始后将SCL也拉低呢？主要有<font color='red'>三个原因</font>：

1. 占用总线：在I2C总线上，可能存在多个主机设备。将SCL拉低可以让其他主机设备知道总线正在被占用，防止其他主机设备在此时进行数据传输。
2. 方便时序拼接：在I2C通信中，数据传输是在SCL为高电平时进行的。然后在下一个SCL周期开始之前，必须先将SCL拉低以保证数据线SDA的稳定。因此，将SCL拉低也是为了准备下一次的数据传输。
3. 保证信号稳定：将SCL拉低可以为下次SDA数据线电平改变操作提供时间，避免SDA电平在SCL高电平过程中发生变化，也即保证了I2C总线的数据稳定。

所以，在I2C起始信号代码中会在起始后将SCL也拉低。



在I2C通信中，数据线SDA的电平变化只有在时钟线SCL为低电平时才允许发生。这是因为，当SCL为高电平时，数据线SDA上的数据被读取或被写入。如果在SCL为高电平时，SDA的电平变化了，那么读取或写入的数据就可能出错。

所以，在开始一个新的数据传输前，必须先将SCL拉低，然后再更改SDA的电平。当确认SDA的电平已经变化稳定后，再将SCL拉高，然后读取或写入数据。这个过程可以确保SDA的电平在被读取或写入时是稳定的，避免了数据的错误读取或写入。

这就是将SCL拉低可以保证数据线SDA的稳定的原因。



# 软件I2C和硬件I2C的区别

[硬件IIC和软件IIC区别_iic是什么硬件-CSDN博客](https://blog.csdn.net/Derricker406/article/details/77171223)

简单应用的情况下，多是使用软件I2C。若是对性能指标要求比较高，则应考虑使用硬件I2C。



# 接受应答

	MyI2C_W_SDA(1);							//接收前，主机先确保释放SDA，避免干扰从机的数据发送
	MyI2C_W_SCL(1);							//释放SCL，主机机在SCL高电平期间读取SDA
	AckBit = MyI2C_R_SDA();					//将应答位存储到变量里

MyI2C_W_SDA(1)已经写1了，AckBit = MyI2C_R_SDA()这里读取不就应该是1了吗？

第一：I2C的引脚都是开漏输出+弱上拉的配置，主机输出1，并不是强置SDA为高电平，而是释放SDA

第二：I2C实在进行通信，主机释放了SDA，那从机又不是在外面看戏，从机要是在的话，它是有义务在此时把SDA再拉低的

所以这里，即使之前主机把SDA置1了，之后再读取SDA，读取的值也可能是0，读到0，代表从机给了应答，读到1，代表从机没给应答。



# 重复起始条件

在I2C（Inter-Integrated Circuit）通信协议中，重复起始条件（Repeated Start Condition）是一个重要的特性。它允许主设备在不释放总线（即不生成停止条件）的情况下，改变数据传输的方向。这是一种在一个I2C事务中从一个设备读取和写入数据的方式。

在配置指定地址读的过程中，重复起始条件的使用场景通常如下：

1. 主设备首先发送一个起始条件，然后发送目标设备的地址和写入位。
2. 主设备发送要读取的寄存器或内存地址。
3. 主设备发送一个重复起始条件，然后发送目标设备的地址和读取位。
4. 主设备读取数据，然后发送一个停止条件。

在这个过程中，重复起始条件允许主设备在告诉从设备要读取哪个寄存器（步骤2）之后，改变数据传输的方向（从写入变为读取）。如果没有重复起始条件，主设备将需要发送一个停止条件，然后发送另一个起始条件来开始新的事务，这会使得总线在两个事务之间有一段时间处于空闲状态，降低了通信效率。

因此，重复起始条件是一种允许主设备在同一个I2C事务中进行读写操作的有效方式，可以提高I2C通信的效率和灵活性。



STM32不通信的时候，就是作为<font color='red'>从机</font>（默认为从机状态）





# 主机发送

EV5时间可以把它当成标志位。这里都是用EV几事件来代替标志位的

EV几事件就是组合了多个标志位的一个大的标志位