# 通信方式对比

每个通信方式所解决的问题

![image-20240307104122862](F:\Typora导出文件\Stm32Typora笔记\assets\image-20240307104122862.png)

<font color='red'>USART：只能一对一通信</font>

# 1.引脚

TX（Transmmit Exchange）

EX  (Receive Exchange)

# 2.波特率

波特率是数据通信中每秒传输的符号数的度量。它以波特为单位，符号是调制信号的状态变化。例如，如果您使用 2 波特率，则信号每秒将改变状态两次。

波特率不是比特率的同义词，比特率是每秒传输的比特数的度量。波特率和比特率之间可能存在关系，具体取决于使用的调制方案。例如，如果使用 2 波特率且每个符号表示 1 比特，则比特率将为 2 比特/秒。但是，如果使用 2 波特率且每个符号表示 2 比特，则比特率将为 4 比特/秒。

波特率用于各种数据通信应用，包括：

- **串行通信：**串行通信是指数据一次一位地发送。波特率用于确定数据发送的速度。
- **调制解调器：**调制解调器用于将数字数据转换为模拟信号，以便可以通过模拟线路传输。波特率用于确定调制解调器的传输速度。
- **数字信号处理：**数字信号处理 (DSP) 用于处理数字信号。波特率用于确定 DSP 系统的采样率。

波特率是一个重要的概念，了解数据通信。了解波特率可以帮助您选择合适的通信设备和配置通信系统。

# 3.双工

在通信领域，全双工和半双工是指通信双方之间数据传输的方向和方式。

**全双工**

全双工是指通信双方可以同时发送和接收数据。这就像两个人同时打电话，他们可以同时说话和听到对方的声音。

全双工通常用于需要实时通信的应用，例如：

- 电话
- 视频会议
- 网络游戏

**半双工**

半双工是指通信双方只能在同一时间内发送或接收数据。这就像两个人使用对讲机，他们只能轮流说话。

半双工通常用于不需要实时通信的应用，例如：

- 打印机
- 扫描仪
- 传感器

**区别**

全双工和半双工的主要区别在于它们允许同时发送和接收数据的能力。

- **全双工**允许同时发送和接收数据。
- **半双工**只能在同一时间内发送或接收数据。

**选择**

选择使用全双工还是半双工取决于应用程序的具体需求。

- **如果需要实时通信，则应使用全双工。**
- **如果不需要实时通信，则可以使用半双工。**

**总结**

全双工和半双工是两种不同的通信方式。选择使用哪种方式取决于应用程序的具体需求。

以下是一些关于全双工和半双工的额外信息：

- **全双工通常需要两根数据线，一根用于发送数据，另一根用于接收数据。**
- **半双工通常只需要一根数据线，用于发送和接收数据。**
- **全双工的通信速度通常比半双工快。**
- **半双工的成本通常比全双工低。**



单工：数据只能从一个设备到另一个设备，而不能反着来（比如把USART的RX引脚去掉）（只能输出或只能输入）

4.TTL电平（晶体管-晶体管逻辑电平）

数据帧位数：<font color='red'>一般八位数据是最常用的，多了一位就经常是当作校验位，防止传输时出现的数据错误</font>

<font color='red'>最好选择8位字长无校验位，9位字长有校验。</font>



<font color='red'>跳线帽</font>：是用来选择通信电平的，也是给CH340芯片供电的



# 4.*串口接收*

## STM32串口接收查询和中断方法的优劣和实现流程

**一、查询方法**

**1. 优点**

- 实现简单，易于理解。
- 不需要配置中断，程序结构清晰。
- 对CPU资源占用少。

**2. 缺点**

- 效率低，需要频繁轮询查询数据，浪费CPU时间。
- 无法及时响应接收数据，容易丢失数据。
- 不适合接收大量数据或实时性要求高的应用。

**3. 实现流程**

- 配置串口波特率、数据位、校验位等参数。
- 进入循环，不断读取串口接收寄存器，判断是否有数据接收。
- 如果有数据接收，则读取数据并进行处理。

**示例代码：**

C

```c
while (1) {
  // 查询串口接收寄存器
  if (USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == SET) {
    // 读取接收数据
    uint8_t data = USART_ReceiveData(USARTx);
    // 处理接收数据
  }
}
```

**二、中断方法**

**1. 优点**

- 效率高，只有在接收到数据时才会触发中断，节省CPU时间。
- 能够及时响应接收数据，避免丢失数据。
- 适合接收大量数据或实时性要求高的应用。

**2. 缺点**

- 实现相对复杂，需要配置中断服务函数。
- 对CPU资源占用略多。

**3. 实现流程**

- 配置串口波特率、数据位、校验位等参数。
- 配置串口接收中断。
- 编写串口接收中断服务函数，在中断服务函数中读取数据并进行处理。

**示例代码：**

C

```C
void USARTx_IRQHandler(void) {
  // 判断接收中断标志
  if (USART_GetITStatus(USARTx, USART_IT_RXNE) != RESET) {
    // 清除接收中断标志
    USART_ClearITPendingBit(USARTx, USART_IT_RXNE);
    // 读取接收数据
    uint8_t data = USART_ReceiveData(USARTx);
    // 处理接收数据
  }
}
```

**三、总结**

查询方法和中断方法各有优劣，选择哪种方法取决于应用需求。如果应用对效率要求不高，且接收数据量不大，可以选择查询方法。如果应用对效率要求高，或需要接收大量数据，则可以选择中断方法。

**以下是一些建议：**

- 对于简单的数据接收应用，可以使用查询方法。
- 对于需要及时响应接收数据或接收大量数据的应用，可以使用中断方法。
- 如果需要在查询和中断方法之间进行权衡，可以考虑以下因素：
  - 数据接收的频率
  - 数据接收的及时性
  - 对CPU资源的占用



## 串口通信收发数据包进入中断的原因

在 STM32 中，串口收发数据包进入中断有以下几个原因：

**1. 提高效率**

串口通信是一个异步过程，这意味着发送方和接收方之间不需要同步时钟。因此，如果 CPU 一直等待串口数据到达，则会浪费 CPU 时间。使用中断可以使 CPU 在等待串口数据到达时执行其他任务，从而提高效率。

**2. 提高可靠性**

串口通信可能会受到噪声和其他干扰的影响。使用中断可以提高数据接收的可靠性，因为 CPU 可以在数据到达时立即处理它，从而减少数据丢失的可能性。

**3. 支持多任务**

如果应用程序需要同时处理多个串口，则可以使用中断来处理每个串口的接收和发送数据，从而支持多任务。

**4. 降低功耗**

如果 CPU 一直等待串口数据到达，则会消耗更多功耗。使用中断可以使 CPU 在等待串口数据到达时进入低功耗模式，从而降低功耗。

**进入中断的好处**

进入中断可以带来以下好处：

- **提高效率**
- **提高可靠性**
- **支持多任务**
- **降低功耗**

**示例**

以下是一个使用中断接收串口数据的示例：

C

```
void USART1_IRQHandler(void)
{
  // 读取接收到的数据
  uint8_t data = USART1->DR;

  // 处理数据
  // ...

  // 清除中断标志
  USART1->SR &= ~USART_SR_RXNE;
}
```

在这个示例中，当接收到串口数据时，会触发 USART1_IRQHandler() 中断服务程序。在这个中断服务程序中，可以读取接收到的数据并进行处理。

**总结**

在 STM32 中，串口收发数据包进入中断可以提高效率、提高可靠性、支持多任务和降低功耗。



# 重定义fputc函数到串口printf输出（代码 + 应用实例）

[重定义fputc函数到串口printf输出（代码 + 应用实例）-CSDN博客](https://blog.csdn.net/lnfiniteloop/article/details/123092267)

printf 最终会调用 fputc 进行字符串输出

